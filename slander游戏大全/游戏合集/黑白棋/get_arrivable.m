function outcome=get_arrivable(board,t)
% 找到找到黑子或者白子可以下棋的位置并输出为outcome
% board ：棋盘数组，没有棋子处为0,黑棋为1,白棋为-1
% ===============================================================
% 例：
% 我们若是下一步要下黑棋，就要先找到所有黑棋位置
% 再找到每一个黑棋旁边紧挨着白棋，再顺着该方向[黑棋->白棋]一直找，
% 直到找到紧挨着白棋的空白，该空白是一个黑棋可下子处,所有可下子处的集合
% 就是我们要找的outcome
% ---------------------------------------------------------------
% 但是为了方便代码编写，我们对流程稍加改进（以黑子为例）：
% [1] 找到每一个黑子的位置
% [2] j=1:8分八个方向找到该棋子该方向上所有位置的情况
%     例如某黑色棋子(星号)左右情况为：○*○○囗●○○
%     则其右侧方向棋子情况为：○○囗●○○
% [3] 判断某方向棋子第一个是白子，上面例子第一个就是白子
% [4] 如果某防线棋子第一个是白子，删除该方向所有白子
%     上面的例子删除后长这样：囗●
% [5] 如果删除后，第一个位置为空，则该位置为可行位置，上例第一个就是囗，
%     所以是可行位置
% [6] 找到所有可行位置，并删除重复项

% 输出集合初始化
outcome=[0 0];
outcome(1,:)=[];

switch t
    case 1,t=1;
    case 0,t=-1;  
end

% 首先找到棋盘中(黑/白)子位置
[x,y]=find(board==t);
collection=[x,y];

% 上下左右八个方向
dir=[1 0;-1 0;0 1;0 -1;1 1;-1 -1;1 -1;-1 1];


if ~isempty(collection) % 如果棋盘上有棋子(这句话其实有没有都一样)
for i=1:size(collection,1)% 遍历某颜色全部棋子
    for j=1:8% 分别搜索八个方向
        
        % 找到某方向全部棋子，由于棋盘每个方向都最多有八个棋子，所以，以
        % 要检测棋子为中心，向某方向取七个位置就能取到全部位置，超出棋盘
        % 的删掉即可
        temp_set=collection(i,:)+((1:7)')*dir(j,:);
        temp_set(temp_set(:,1)>8|temp_set(:,1)<1,:)=[];
        temp_set(temp_set(:,2)>8|temp_set(:,2)<1,:)=[];
        
        if ~isempty(temp_set)% 如果该棋子某方向还有位置(棋子由可能贴着边，那么那个方向就没有检测的必要)
            % 获取棋子某方向所有位置情况(黑/白/空)
            temp_value=board(temp_set(:,1)+(temp_set(:,2)-1).*8);
            
            % 如果紧挨着的是棋子且为相反颜色
            if temp_value(1)==-t
                
                % 删除该方向全部相反颜色的棋子
                temp_set(temp_value==-t,:)=[];
                temp_value(temp_value==-t)=[];
                
                if ~isempty(temp_set)
                    if temp_value(1)==0% 在紧挨为反色的前提下如果第一个不是反色的是空位置
                        % 将该位置并入结果集合
                        outcome=[outcome;temp_set(1,:)];
                    end  
                end
            end  
        end
    end
end
end
